# -*- coding: utf-8 -*-
"""photos

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_fjYUKup_osxS9Qoi9tPQHGmcvWU5kzV
"""

# Slideshow with vertical & Horizontal photos. Scoring is calculated with linked tags.
# If photos were vertical, two must be combined in one slide. Tags were union of both photos tags
# Linked slides match scoring por slideshow.
# linkable tags with only one appearance qualify photos:
#  ---Horizontal photo for only use with ends of slideshows.
#  ---Vertical photo for only bundle slide with other vertical photo to link two ways.
# 
#

"""## Previous config and functions section

### Imports and configs
"""

# Import and package configuration
#import matplotlib.pyplot as pyplot
#from pylab import *
#import networkx
#import time

# Import and package configuration
from google.colab import files
from itertools import combinations

"""### Download files from Hashcode instance"""

# Download data files from hashcode

#!wget -O example.in  "https://hashcodejudge.withgoogle.com/download/blob/AMIfv97QHzUItY7To0o6id8E6_kxpE1KwTlPR1T9yC2zlbm46xvPPX7tBn1r5ZNxw9XboxHkVKa82BzM-B65uM92pJRONqfeVlHfpzH8xbqKc9FrAWJnd3Yp5SF7naqscxmnBjTa3R-UcB_bqg5hoAa0TZFXIlvi-RL6y_daJXyNUUHeP1kBxQss_1b2nNbNFg7W3Jtgyl2Vs86QrufNrQcUlNh754HyhRrhV3yJBo66HdYQAa2lPISjoUkUTpWqqrGIEItpPu27GNqcp2I69D8j8A-70B30oU-w7zIe9DJ9xnpC70T6T88"

!wget -O lovely.in "https://hashcodejudge.withgoogle.com/download/blob/AMIfv977kmeJsFQfgJNbIlAkviRDMVQcDWj0hLBMvhyg8SuPR52vtGV8uIJsB5nnPDX1Rp14OqzXWF-XXUKp3hhFjdL9PtHAOemuN-rKrd_OgY8pQ6SwgBlBcwPm-5Ova9XoGHSlhT2iLskxOoetjmTNQ8upzsFVkCQqh0gM0P-VX2nWmyxSfIFGmv373rdp9k1Bw9iMdhZXxuMfYIPaWJ8c6izWNYsl9Mpk1a7R0DjShNoDn6Nbfghj_S9bkjGgJS6Clz0b3rMqhHyHAxuIVMnfw1ppwWK_z5TYb4Tsz1vzNERAVPtnuSw"

#!wget -O memoments.in "https://hashcodejudge.withgoogle.com/download/blob/AMIfv94hwk1wpXjU-qRaszhHtsN4gJSGTkGGNfiItXwzXwhtP6IGrdiZrJ16XvlGFZAKOck8csLoiqwaDiJY6pybACZPZoBnwUMB_WLmQPR7XwH_0AMzk4at1sNgwB_f-9wOwSaqAQE8VtIlLNLDOLeo9sJDLxUVceOopaGh93MDCof4KCYXcdvM9tCSQz1sT89KVmM3Qx0Rz0JkXm4-a3mTk_676DubwwI5siY-ulC87_p1qcfeWdJXmuqMO7E-8THazayXZmS2dXyeTWiOOt27fOC06dSTe9mYfNBISojtloNJc-9Xohc"

#!wget -O petpict.in "https://hashcodejudge.withgoogle.com/download/blob/AMIfv95TypJhkPij61j5cS87pz5lYAw7u6lKSxctMX0zPI_8N7y-bRcwGLHe8rx8vAaQ_Dszh0yuWjpdXucxsC52Fq-iuNeI9D8ugsj3djcsDH5Ax3TlTILi27GOCPv_-U7KZsyrbKusR5T8saKHiE2cferYs92JBV_nKxm7gxQkzITercTAfcJaEtenWiTS4rhPkIVARXCQE9LaycZvxV4IqTnDCfYHZhtFVV9_Y_h5riDVjGZZd01tplZ1aibiKASlJZulxOwnJGfmgrYkImN3dCaDYx0eAGlGUoRjAF3GsiGdZ4bI0_V-lKZJlSdoMPxCctPLpgvL"

#!wget -O shinyself.in "https://hashcodejudge.withgoogle.com/download/blob/AMIfv941-URwsmc_UpuUvypgEBaH_U4oDiPKJZR_gk2oNcK8NXMmcZMwFC8qM3aYM_G1dN5hhRt9ONNq_o1RLVdWXqFn6M_DFVf_UnLD0E7Qg-D989lrG08e5FWD06_crrlGQI48euVgJSyEHO2oo8_3506xyzI2KsMLs_zPfjnnRr6sVKSMeQLNWRD4gut2m1QBzkRWvZuigNbXsCFra7wNPrEdPCI4Mf11W9rWcMrVsvMcrAmjw02vPbqqe8QrVwM08n0tMfAvk01BwBEM8RcwkYtkp8IUP3M0_67Sum1zfuFayeLWSOY"

!ls -l

"""### Create Data Structures and load data from/to file, scoring"""

# Load data file function. Parameters: nom = name of input file, test = 'Test debug mode False or True'
# # def loaddata(nom,test):return
# nphotos	# Number of photos
# ,photos	# Data for all photos
# ,photosv# Data for vertical photos
# ,photosh# Data for horizontal photos
# ,nv	# number of vertical images
# ,nh	# Number of horizontal images
# ,nctags	# Not linkable tags
# ,ncphotos# Not linkable photos
# ttags	# Tag global number occurrences
# dtags	# tags occurrence, dictionary
# dtag_ph# Tag dictionary pointer to tag_ph photos list for each tag
# tag_ph	# photos list for each tag, indexed

def loaddata(nom,test):
  file = open(nom,'r')
  line = file.readline()
  # Assign number of photos from first line
  nphotos = int(line.rstrip()) # Number of photos
  nv = 0 # number of vertical images
  nh = 0 # Number of horizontal images
  phpt = 0 # photo pointer position to videos list for each tag
  ttags = 0 # Tag global number occurrences 
  nctags = set() # Not linkable tags
  ncphotos = set() # Not linkable photos
  dtags = {} # tags occurrence, dictionary
  dtag_ph = {} # Tag dictionary pointer to tag_ph photos list for each tag
  photos = [] # Data for all photos
  photosv = [] # Data for vertical photos
  photosh = [] # Data for horizontal photos
  tag_ph = [] # photos list for each tag, indexed
  # Read all image descriptions
  for i in range(nphotos):
    lista = []
    lista = file.readline().rstrip().split(' ')
    lista.insert(0,i) # Insert image number
    tags = set(lista[3:]) # Store tags as a set
    for t in tags: # Adds tag occurrences to dictionary
      if t in dtags:
        dtags[t] += 1
        tag_ph[dtag_ph[t]].append(i)
      else:
        dtags[t] = 1
        dtag_ph[t] = phpt
        tag_ph.append([])
        tag_ph[phpt].append(i)
        phpt += 1
    ntags = int(lista[2]) # Convert to int  tag number for photo
    lista = lista[:2] # Crop list
    # Count number of vertical or horizontal images
    # Append elements to list
    lista.append(ntags) # Number of tags
    lista.append(tags) # Set of tags
    ttags += ntags 
    photos.append(lista)
    if lista[1] =='V':
      nv +=1
      photosv.append(lista) # Add vertical image list data to photos list.
    else:
      nh +=1
      photosh.append(lista) # Add horizontal image list data to photos list.
    if test:
      print(photos[i])
  file.close()
  print('N. fotos:',nphotos,'Fotos Verticales:',nv,'Fotos Horiz:',nh,'Tags no combinables horizontales:',len(nctags),'Apariciones Tags:',ttags,'Tags diferentes:',len(dtags),'Media Tags/ imagen:', ttags/len(dtags))
  return nphotos, photos, photosv, photosh, nv, nh, nctags, ncphotos, ttags, dtags, dtag_ph, tag_ph

# Write Output data to a file, and download via google.colab files, drive or other
def writedata(nom,slideshow):
  file=open(nom,'w')
  file.write(str(len(slideshow))+'\n')
  for i in slideshow:
    if i == 2:
      file.write(' '.join(str(e) for e in i)+'\n')
    else:
      file.write(str(i)+'\n')
  file.close()
  files.download(nom) # google colab files download
  return

def scoring(photos, ph1_1,ph2_1,ph1_2 = -1, ph2_2 = -1, test = False):
  
  # Set tags for slide1 with id photos
  if ph1_2 == -1 :
    tag1 = photos[ph1_1][3]
  else:
    tag1 = photos[ph1_1][3] | photos[ph1_2][3]
  if test:
    print('Tags fotos', ph1_1,' ', ph1_2, 'de slide 1', tag1)
  # Set tags for slide2 whith id photos
  if ph2_2 == -1:
    tag2 = photos[ph2_1][3]
  else:
    tag2 = photos[ph2_1][3] | photos[ph2_2][3]
  if test:
    print('Tags fotos', ph2_1,' ', ph2_2, 'de slide 2', tag2)
  # Calculate optional scoring
  sctag_int = tag1 & tag2
  sctag1not2 = tag1 - tag2
  sctag2not1 = tag2 - tag1
  sc_int = len(sctag_int)
  sc1not2 = len(sctag1not2)
  sc2not1 = len(sctag2not1)
  score = min(sc_int, sc1not2, sc2not1)
  if test:
    print('Interseccion: Num.tags:', sc_int)
    print(sctag_int)
    print('En slide1 pero no en slide2. Num.tags:', sc1not2)
    print(sctag1not2)
    print('En slide2 pero no en slide1. Num.tags:', sc2not1)
    print(sctag2not1)
  return score

"""### Display utilities for analysis"""

# Listing function 
def lista(photos, limit = 15):
  # Linkable photos list
  num = len(photos)
  fila = 0
  for foto in photos:
    print(foto)
    num -= 1
    fila += 1
    if fila >= limit:
      print(num, 'Elements pending to list')
      break

# Listing set of tags function
# tags # set of elements
# limit # max. number  of lines listed
# nrow # max number of elements at each row
def listags(tags, limit = 50, nrow = 18):
  # Lista tags
  num = len(tags)
  listed = 0
  columna = 0
  for tag in tags:
    print(str(tag),'\t', end='')
    num -= 1
    listed += 1
    columna += 1
    if columna >= nrow:
      print()
      columna = 0
    if listed >= limit:
      print()
      print('Tags pendientes de listar:', num)
      break

def listupla(dicc, limit=500, nrow = 18, valor = 0):
  # Lista tags
  num = len(dicc)
  listed = 0
  columna = 0
  for tupla in dicc:
    if dicc[tupla] >= valor:
      print(tupla,':',dicc[tupla],'\t', end='')
      num -= 1
      listed += 1
      columna += 1
      if columna >= nrow:
        print()
        columna = 0
    if listed >= limit:
      print()
      print('Tags pendientes de listar:', num)
      break

def photos4tag(dtag_ph, tag_ph, limit=10, nrow = 6):
  num = len(dtag_ph)
  listed = 0
  columna = 0
  for t in dtag_ph:
    ptlist = dtag_ph[t]
    print(t,'\t[', ptlist, ']->',tag_ph[ptlist],'\t',end='')
    #print('\t\tCombinaciones:',list(combinations(tag_ph[ptlist],2)))
    num -= 1
    listed += 1
    columna += 1
    if columna >= nrow:
      print()
      columna = 0
    if listed >= limit:
      print()
      print('Tags pendientes de listar:', num)
      break

def link2photos(photos, id1,dtag_ph,tag_ph,test=False):
  if test:
    print(photos[id1])
  idset = set()
  idset.add(id1)
  dnphotos = {}
  tags_id1 = photos[id1][3]
  if test:
    print()
  for t in tags_id1:
    ptlist = dtag_ph[t]
    if test:
      print(t,'\t',ptlist,'\t', end='')
      print(tag_ph[ptlist],'\t',end='')
      print('\tCombinaciones:',end='')
    cphotos = set() # photos set combinations
    for c in list(combinations(tag_ph[ptlist],2)):
      cphotos.add(c[0])
      cphotos.add(c[1])
      cphotos = cphotos - idset
      if test:
        print(cphotos,end='')
      cpop =cphotos.pop()
      if cpop in dnphotos:
        dnphotos[cpop] += 1
      else:
        dnphotos[cpop] = 1
    if test:
      print()
  if test:
    print(dnphotos)
  return dnphotos

"""### Functions to optimize process"""

def purgedict(dtags,nctags, test):
  tuplas = list(dtags.items())
  j = 0
  for i in tuplas:
    #print('\t',dtags[tuplas[j][0]],end='')
    if dtags[tuplas[j][0]]<=1:
      if test:
        print ('----->Tag:', i, 'no combinable...eliminando de dtags y a√±adiendo a nctags')
      nctags.add(tuplas[j][0]) # Add at not linkable tags set
      del(dtags[tuplas[j][0]]) # remove tuple from dictionary for number of occurrences to this tag
      del(dtag_ph[tuplas[j][0]]) # remove tuple from dictionary pointer to list of photos where appear this tag
    j+= 1
  tuplas = []
  print('N. fotos:',nphotos,'Fotos Verticales:',nv,'Fotos Horiz:',nh,'Tags no combinables horizontales:',len(nctags),'Apariciones Tags:',ttags,'Tags diferentes:',len(dtags),'Media Tags por imagen:', ttags/len(dtags))
  return dtags,nctags

# Purge for unlinkable tags at photos list
def purgetags(photos, nctags, test):
  #print('Purgando tags no combinables en lista de fotos')
  ttags = 0
  for photo in photos:
    if test:
      print(photo,end='')
    photo[3]=photo[3]-nctags
    photo[2]=len(photo[3])
    ttags += photo[2]
    if test:
      print('++',photo[3])
  print('N. fotos:',len(photos),'Apariciones Tags:',ttags,'Tags diferentes:',len(dtags),'Media Tags por imagen:', ttags/len(dtags))
  return photos, nctags,ttags

# Purge for photos that can't be linked
def purgephotos(photos, nctags, rango, test):
    cont = 0
    print('Fotos que son menos combinables.',rango,' tags combinables') 
    for photo in photos:
      if len(photo[3]-nctags)<=rango:
        if test:
          print(photo)
          print('tags - nctags:', end='')
          print(photo[3]-nctags)
          print('--------------------')
        print('+')
        cont +=1
      # else:
        #if test:
        #  print(photo)
        #  print('tags - nctags:', end='')
        #  print(photo[3]-nctags)
        #  print('-',end='')
    print(cont, 'menos combinables')

# Find the best option to combine two horizontal slides. NOT USED NOW
def link(photos, test ):
  pos_candidato1 = 0
  pos_candidato2 = 0
  maxint = 0
  ptpic = 0
  for pic in photos:
    if test:
      print('++', ptpic, '\t++', photos[ptpic],'+++')
    for pointer in range(ptpic+1,len(photos)):
      inter = pic[3] & photos[pointer][3]
      ninter = len (inter)
      if test:
        print('Foto Puntero:', pic, 'Foto a comparar:',photos[pointer], 'Interseccion:', end='')
        print (inter,'Tags comunes:',ninter)
      if ninter > maxint:
        pos_candidato1 = ptpic
        pos_candidato2 = pointer
        maxint = ninter
        print('Candidatos', photos[pos_candidato1],'+', photos[pos_candidato2], 'Inters:', inter, 'Ntags:', ninter)
    ptpic += 1

"""## Process Data Section before select upshot to problem

### Load data.
"""

# Load data from file, Create Data Structures
nphotos, photos, photosv, photosh, nv, nh, nctags, ncphotos, ttags, dtags, dtag_ph, tag_ph = loaddata('lovely.in',False)

lista(photos,5)

print(scoring(photos, 0,6674, test=True))

"""### Remove unlinkable tags on dictionary"""

# Indexed photos list for each tag where appears
photos4tag(dtag_ph,tag_ph,10,1)

# List number of ocurrences for each tag on all photos
listupla(dtags,50,15)

# Purge tags to nctags set and delete to associated dictionaries
dtags, nctags = purgedict(dtags, nctags, False)

# List set of tuples as number of ocurrences for each tag in photos list after purging
listupla(dtags,50,17)

# List photos associated to a tag, after purging not linkable tags.
photos4tag(dtag_ph,tag_ph,10,1)

# List set of not linkable tags
listags(nctags,100,18)

"""### ### Remove unlinkable tags on video lists"""

lista(photos,5)

photos, nctags, ttags = purgetags(photos,nctags,False)

lista(photos,5)

# Remove not linkable tags after Data Structures were processed
nctags = set()

"""### Other"""

photos4tag(dtag_ph,tag_ph,8,1)

link2photos(photos,0, dtag_ph, tag_ph),

link2photos(photos,6674, dtag_ph, tag_ph)

link2photos(photos,13708, dtag_ph, tag_ph)

listupla(link2photos(photos,14519, dtag_ph, tag_ph))

link2photos(photos,18143, dtag_ph, tag_ph)

link2photos(photos,74267, dtag_ph, tag_ph)

link2photos(photos,78134, dtag_ph, tag_ph)

idphotos = set()
for i in range(len(photos)):
  idphotos.add(i)

listags(idphotos,200,38)

slideshow =[]
idphoto = 41000
idphotos.remove(41000)
slideshow.append(idphoto)
slideshow

#linkphoto = link2photos(photos,idphoto, dtag_ph, tag_ph)
#listupla(linkphoto)

while True:
  linkphoto = link2photos(photos,idphoto, dtag_ph, tag_ph)
#  listupla(linkphoto)
  for i in linkphoto:
    #print(i,'\t',end='')
    j = len(linkphoto)
    if i in idphotos:
      # print('Nueva:',i)
      slideshow.append(i)
      idphotos.remove(i)
      idphoto = i
      break
    else:
      #print('Coincidente')
      j -= 1
      continue
    if j == 0:
      #print('Sin combinaciones')
      break
  if len(idphotos) == 0:
    break

writedata('lovely.out',slideshow)

len(slideshow)

ls



# purgephotos(photos, nctags, 6,False)

# link(photos,False)